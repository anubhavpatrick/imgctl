#!/bin/bash
# ============================================================================
# imgctl - Cluster Image Management Tool
# ============================================================================
# A scalable CLI tool for managing and viewing container images across a
# BCM cluster with NVIDIA DGX nodes and Harbor private registry.
#
# This tool provides:
#   - View images on worker nodes (via crictl)
#   - View images in Harbor registry
#   - Compare images across nodes
#   - Multiple output formats (table, json, csv)
#
# Author: Anubhav Patrick <anubhav.patrick@giindia.com>
# Organization: Global Info Ventures Pvt Ltd
# Date: 2025-12-02
# ============================================================================

set -o pipefail # This is used to exit the script if any command in the pipeline fails

# Resolve the actual installation directory
# This handles the case where imgctl is symlinked from /usr/local/bin
# -L is used to check if the file is a symlink
if [[ -L "${BASH_SOURCE[0]}" ]]; then
    # Follow the symlink to get the real path
    REAL_PATH="$(readlink -f "${BASH_SOURCE[0]}")"
    SCRIPT_DIR="$(cd "$(dirname "$REAL_PATH")" && pwd)"
else
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi

# Library directory is relative to the actual script location
LIB_DIR="${SCRIPT_DIR}/../lib"

# Verify library directory exists
if [[ ! -d "$LIB_DIR" ]]; then
    # Log detailed error to fallback location (before logging framework is loaded)
    local error_log="/var/log/giindia/imgctl/imgctl-error.log"
    mkdir -p "$(dirname "$error_log")" 2>/dev/null
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [ERROR] Library directory not found at $LIB_DIR" >> "$error_log" 2>/dev/null
    # Show generic message to user (no internal paths)
    echo "Error: imgctl installation is incomplete or corrupted." >&2
    echo "Please contact your system administrator." >&2
    exit 1
fi

# Source library modules with secure error handling
# Log detailed errors but show generic messages to users
_log_module_error() {
    local module="$1"
    local error_log="/var/log/giindia/imgctl/imgctl-error.log"
    mkdir -p "$(dirname "$error_log")" 2>/dev/null
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [ERROR] Failed to load module: ${LIB_DIR}/${module}" >> "$error_log" 2>/dev/null
    echo "Error: imgctl installation is incomplete or corrupted." >&2
    echo "Please contact your system administrator." >&2
    exit 1
}

source "${LIB_DIR}/common.sh" || _log_module_error "common.sh"
source "${LIB_DIR}/crictl.sh" || _log_module_error "crictl.sh"
source "${LIB_DIR}/harbor.sh" || _log_module_error "harbor.sh"
source "${LIB_DIR}/output.sh" || _log_module_error "output.sh"

# ----------------------------------------------------------------------------
# USAGE AND HELP
# ----------------------------------------------------------------------------

show_usage() {
    cat << EOF
${BOLD}imgctl${NC} - View container images across your BCM cluster

${BOLD}USAGE:${NC}
    imgctl COMMAND [OPTIONS]

${BOLD}COMMANDS:${NC}
    get [SCOPE]        Get container images
                       SCOPE options:
                         all      - All images (default)
                         harbor   - Harbor registry images only
                         nodes    - Worker node images only

    compare            Compare images across worker nodes

    help               Show this help message

${BOLD}OPTIONS:${NC}
    -o, --output FORMAT    Output format: table|json|csv (default: table)
    --no-color             Disable colored output
    -q, --quiet            Quiet mode (minimal output)
    --version              Show version information

${BOLD}EXAMPLES:${NC}
    imgctl get                    # Get all images
    imgctl get harbor             # Get Harbor images only
    imgctl get nodes              # Get all node images
    imgctl get -o json            # Output in JSON format
    imgctl compare                # Compare images across nodes

${BOLD}VERSION:${NC}
    $VERSION

EOF
}

show_version() {
    echo "imgctl version $VERSION"
    echo "Author: Anubhav Patrick <anubhav.patrick@giindia.com>"
    echo "Organization: Global Info Ventures Pvt Ltd"
}

# ----------------------------------------------------------------------------
# COMMAND HANDLERS
# ----------------------------------------------------------------------------

# Handle 'get' command
cmd_get() {
    local scope="${1:-all}"
    shift 2>/dev/null || true 
    
    local harbor_images="[]"
    local node_images="{}"
    local comparison=""
    
    case "$scope" in
        all)
            log_info "Getting all images (Harbor + nodes)"
            harbor_images=$(get_harbor_images)
            node_images=$(get_all_nodes_images)
            comparison=$(compare_node_images "$node_images")
            ;;
        harbor)
            log_info "Getting Harbor images only"
            harbor_images=$(get_harbor_images)
            ;;
        nodes)
            log_info "Getting all node images"
            node_images=$(get_all_nodes_images)
            comparison=$(compare_node_images "$node_images")
            ;;
        *)
            log_error "Invalid scope: $scope"
            print_error "Invalid scope: $scope"
            echo "Valid scopes: all, harbor, nodes"
            return 1
            ;;
    esac
    
    # Display output
    display_output "$OUTPUT_FORMAT" "$harbor_images" "$node_images" "$comparison"
}

# Handle 'compare' command
cmd_compare() {
    log_info "Comparing images across nodes"
    
    local node_images
    node_images=$(get_all_nodes_images)
    
    local comparison
    comparison=$(compare_node_images "$node_images")
    
    if [[ "$OUTPUT_FORMAT" == "json" ]]; then
        echo "$comparison" | jq '.'
    else
        format_comparison_table "$comparison"
        
        # Print summary counts
        local common_count
        common_count=$(echo "$comparison" | jq '.common | length')
        
        echo ""
        print_header "Comparison Summary" 60
        echo -e "  ${GREEN}Common images:${NC} $common_count"
        
        echo "$comparison" | jq -r '.node_specific | to_entries[] | "  \(.key): \(.value | length) unique"'
        echo ""
    fi
}

# ----------------------------------------------------------------------------
# MAIN ENTRY POINT
# ----------------------------------------------------------------------------

main() {
    # Default values
    OUTPUT_FORMAT="${DEFAULT_OUTPUT_FORMAT:-table}"
    local no_color=false
    local quiet=false
    
    # Parse global options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -o|--output)
                OUTPUT_FORMAT="$2"
                shift 2
                ;;
            --no-color)
                no_color=true
                shift
                ;;
            -q|--quiet)
                quiet=true
                LOG_LEVEL="ERROR"
                shift
                ;;
            --version)
                show_version
                exit 0
                ;;
            -h|--help|help)
                show_usage
                exit 0
                ;;
            -*)
                log_error "Unknown option: $1"
                print_error "Unknown option: $1"
                echo "Use 'imgctl help' for usage information"
                exit 1
                ;;
            *)
                break
                ;;
        esac
    done
    
    # Disable colors if requested
    if $no_color; then
        RED=""
        GREEN=""
        YELLOW=""
        BLUE=""
        CYAN=""
        NC=""
        BOLD=""
    fi
    
    # Load configuration from system location only
    local found_config
    if found_config=$(find_config); then
        load_config "$found_config"
    else
        log_warning "No configuration file found, using defaults"
    fi
    
    # Initialize
    check_dependencies || exit 1
    init_logging
    init_cache
    
    # Validate configuration
    validate_config
    
    # Get command
    local command="${1:-get}"
    shift 2>/dev/null || true
    
    log_debug "Executing command: $command"
    
    # Execute command
    case "$command" in
        get)
            cmd_get "$@"
            ;;
        compare)
            cmd_compare "$@"
            ;;
        help|-h|--help)
            show_usage
            ;;
        *)
            log_error "Unknown command: $command"
            print_error "Unknown command: $command"
            echo "Use 'imgctl help' for usage information"
            exit 1
            ;;
    esac
    
    # Cleanup old logs periodically
    cleanup_old_logs
}

# Run main function
main "$@"
